
plan (priority - only a few items here plz):
  . triangle mesh importing and tracing (later can be voxelised)
  . a stats structure where stats are collected
    . like how many traversal things per ray/total
    . how many intersections per ray/total
    . how?
      . maybe a global struct + use a macro to either generate no code or the stats code on demand
        so that it can be witched off when not required
        . multiple global vars for each kind of stat. so just execute the macro with the var as input for whatever needs stats, and it keeps track
      . look for some crate?
  . multi-thread syncronised progress indicator
    . what can i do to not slow this down?
      . maybe use channels?
      . atomic add method
  . better img.rs
  . is the function for world(relative to main octree) coords of voxels useful? - then make it
  . add readme with pics and submit it in rt1wk implimentations

currently working on:
  . object octree
    . this is very slow for the sphere scene
      . the non-octree version takes about 40 sec for ~~90 spheres and 400+ seconds for ~~900 spheres
      . the octree version takes about 70-90 secs for ~~90 spheres and 200+ secs for ~~900 spheres
      . but why should it be slow? 90 sphere intersection tests per ray shot vs less than 90 octree traversals(this is kinda efficient too)
      . try a run with just 1 object in main branch/very inner branch
        . 9 sec for 1 obj to 35 sec for 1 object
    . maybe store everything in tree space? so scaling and rotations are easier
  . triangle meshes
    . keep position in struct, we can move objects without having to modify all vertices using it
      . ray pos -= position
      . will also have to keep a matrix to rotate the ray dir correctly
      . this isnt very efficient for static scenes tho cuz we dont need to move objects often
    . store mesh in octree
      . store a triangle in the smallest cube it fits in, dosent matter if its a leaf or branch
        . this way, no duplicates
      . how do i store vertices?
        . duplicate it across triangles?
        . if storing in a vec in TriangleMesh, how do i let the triangle have access to it from inside octree.hit
          . use a global variable which is pointer to the vertices vec. this is unsafe, but whatever
          . or duplicate the octree once more? for the specifics of triangles
  . how voxelise triangle meshes?
    . triangle meshes are closed usually, so maybe first voxelize every voxel that intersects triangles and then flood-fill the interior
      . the interior can have big voxels
    . maybe voxels can be filled like rasterisation. move a point along the area of triangle and put a voxel there
      . for more accurate things, insert the point a few more levels deep and check if it lies closeish to the centre or lies along boundaries
      . if it lies along the boundaries, then we can either ignore the voxel or check a few more things
        . the normsls of triangles usually point outside, so maybe this can be used to decide if a voxel should go in or not
    . flood-fill the outside and then invert it
    . find bb and sample 8 points within a voxel to decide if it should be filled
      either every voxel.in this can be checked (recursive) (cuz simpler)
      or only check (recursive) that actually intersect
  . octree
    . voxel normals
      . many voxels can have same normal (big triangle), can i do something to save space here?
        . like is no normal, check parents normal recursively
      . i can use marching cubes to create terrain and render it on fly (dont need to store it)
        . if storage is a big prob, then create it while tracing rays, tho this will be slow af
        . mayebe i can cache a few cubes so that we only create the cube once (per thread) and reuse it for all rays in that pixel (group of pixels)
    . dielectric voxels
      . using the input normals for dielectric dont sound too accurate(cuz the ray can enter and exit from different planes), anything better i can do?
        . like use dt for direction change
        . or maybe dt and the cube infered normal + flipped normal
    . compression
      . voxels with no normals and default materials can be considered mergable with voxels that have materials and normals (if not visible)
      . merge similar sibling voxels if all 8 are similar
    . change ray cast depth as t increases maybe?
    . see ram stats + how crazy can i go with it.
      . deepsize on github (idk if crate)
      . as of 2/9/21, it uses about 85MB total (RES memory from top command)
        . out of which around 55MB should be image buffers
        . 100k voxel inputs with normals
      . can i load minecraft maps in it?


todo/ideas:
  . size of object enum is very big
    . voxel octree contributes the most
      . maybe have a info struct or something that is stored in the main struct in a box
    . maybe use Box<dyn trait> instead?
  . multiple samples if material is lambertian ????
  . multi-colored materials (all types?)
    . an extra enum for this? - it can have all the different coloring patterns in it
    . this will look cool on random objects (like the velvet coats or whatever)
    . color as a function of direction of normal (like that of sky)
    . color as func of angle with normal?
  . better fresnel or whatever
    . instead of randomising reflection and refraction, a part of them should bounce and a part should refract
  . make this do the termiRen stuff too
    . dosent seem to difficult - just modify the world struct a bit
  . look into signed distance fields
  . more materials
    . textures
      . custom textured skybox - just another sphere??
    . mixture of metal and lembertian and etc
      . some probability that it behaves in a way
      . can i just have 1 material then?
        . with different settings
    . hollowgram like material
    . is sub-surface scatterng doable for me?
  . fog
    . get 2 limits for t (where there is fog)
    . some probability that it passes/interacts depending on t
    . if interacts, pick some t in the range
    . let it bounce in random direction
    . use voxels? - more ideas in "octree" below
  . 3d fractals using distance estimate funcs for mandlebulb etc
  . a portal
    . maybe any shape + coupled objects
      . different ways the ray comes out
        . fuzz
        . direction
        . color
    . how do i make the objects teleport through these?
  . more shapes
    . rays/lines (will be cool to view rays)
      . how? these are a bit too thin
    . lens
      . this is just the intersection of 2 spheres, so its only where t for both exists for a ray
        but some more constraints are needed, like maybe it should hit outer of sp1 and then inner of sp2
      . m_t_s1 < p_t_s2 where s1 is the sphere further away from ray.pos
        how? -> whenever ray intersects both, it will (mostly) have 4 sols
        so just pick the middle 2  (m_t is ((-b-root(D))/4a) and p_t is -b+rootD...)
    . parabolic/spherical surfaces
  . implement the 3d matrix rotations stuff
    . maybe the current stuff is plenty for this
  . what would happen if i just use 4d vectors and 4d objects (consider a teseract)
    rotate the needed vectors with rotation matrices and and try to render it with similar tech as 3d
    . 3d images? (assigning colors to 3d pixels) can i do anything with this?
      . average the colors down to 2d
    . 2d images?

remember:
