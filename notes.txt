
todo/ideas:
  /. ram probs due to multi-core stuff
    /. this isnt too much of a problem as the size is max 8*5k*5k*(1*8 f64) bytes -> 1.5 GB or *= 3/8 for (3*1 u8)
  . use f64::infinity or whatever consts
  . multiple samples if material is lambertian ????
  . multi-colored materials (all types?)
    . this will look cool on random objects (like the velvet coats or whatever)
    . color as a function of direction of normal (like that of sky)
    . color as func of angle with normal?
  . better fresnel or whatever
    . instead of randomising reflection and refraction, a part of them should bounce and a part should refract
  . more materials
    . textures
      . custom textured skybox - just another sphere??
    . mixture of metal and lembertian and etc
      . some probability that it behaves in a way
      . can i just have 1 material then?
        . with different settings
    . is sub-surface scatterng doable for me?
  . fog
    . get 2 limits for t (where there is fog)
    . some probability that it passes/interacts depending on t
    . if interacts, pick some t in the range
    . let it bounce in random direction
  . a portal
    . maybe any shape + coupled objects
      . different ways the ray comes out
        . fuzz
        . direction
        . color
    . how do i make the objects teleport through these?
  . bounding boxes using 2 vectors
  . triangle meshes
    . how do i store the vertices? just a vec wouldnt be very efficient
    . maybe mesh bounding box, + some structure with bounding boxes of groups of triangles
    . keep position in struct, we can move objects without having to modify all vertices using it
      . ray pos -= position
      . will also have to keep a matrix to rotate the ray dir correctly
      . this isnt very efficient for static scenes tho cuz we dont need to move objects often
    . maybe aabb thing for triangels and oct-tree for rest?
    . oct-tree 
      . this way, i can have a lot of objects without too much probs
      . i can use marching cubes to create terrain and render it on fly (dont need to store it)
        . if storage is a big prob, then create it while tracing rays, tho this will be slow af
        . mayeb i can cache a few cubes so that we only create the cube once (per thread) and reuse it for all rays in that pixel (group of pixels)
      . how do i store triangles in it tho?
        /. VERY COMPLEX IT SEEMS
        \. triangles can be huge and will have to exist in multiple cubes
          \. sorting is kinda easy once we have the cubes - just use the bounding box to add it to every cube it intersects with
        \. or triangles can be stored in oct-tree using some index in array of triangles
          \. finding what cubes to put the triangle in is a pain tho. but atleast it doable this way
          \. so, go through each triangle and see what cubes it should be in, then re-do that part of oct-tree for max no. of things in a voxel thing
             or whatever in recursive fashion
            \. but some exceptions should be there while doing this, cuz many triangles can share same vertex
        \. or clip triangles till it fits in a leaf + limit to how small it can go
        . OR store a triangle in the smallest cube it fits in, dosent matter if its a leaf or branch
          . this way, no duplicates
      . maybe convert triangle meshes into voxel things first and then do the tracing
        . how voxelise?
          . triangle meshes are closed usually, so maybe first voxelize every voxel that intersects triangles and then flood-fill the interior
            . the interior can have big voxels
            . maybe voxels can be filled like rasterisation. move a point along the area of triangle and put a voxel there
        . voxels can be efficiently stored in an octree
          . enum u8 with 1bit is 1 subvoxel in it, if it contains more levels then it has u8 in it
            \. 1GB -> smallest leaf is 1mm, 128*128 metreÂ³ volume (completely full octree)
              \. but nor info? like normals and colors and materials
            . how materials + color?
              \. (nope dosent work like that) empty enums with each voxel? how tf would this work. no extra space is used, but then how is it even possible?
              \. store color in the biggest voxel of all same type, same with voxel type
                \. im already doing sparse compression thing tho
              . store all unique materials and colors (seperately) in vecs and have voxels(parent branch, not leaves) 
                contain a u32/u16(68k possibilities) index value to this
              . or have each branch store the materials of their children
  . more shapes
    . rays/lines (will be cool to view rays)
      . how? these are a bit too thin
    . lens
      . this is just the intersection of 2 spheres, so its only where t for both exists for a ray
        but some more constraints are needed, like maybe it should hit outer of sp1 and then inner of sp2
      . m_t_s1 < p_t_s2 where s1 is the sphere further away from ray.pos
        how? -> whenever ray intersects both, it will (mostly) have 4 sols
        so just pick the middle 2  (m_t is ((-b-root(D))/4a) and p_t is -b+rootD...)
    . parabolic/spherical surfaces
  . implement the 3d matrix rotations stuff
    . maybe the current stuff is plenty for this
  . what would happen if i just use 4d vectors and 4d objects (consider a teseract)
    rotate the needed vectors with rotation matrices and and try to render it with similar tech as 3d
    . 3d images? (assigning colors to 3d pixels) can i do anything with this?
    . 2d images?

remember:
  . try reflections from inside a big sphere
    . its too dark, no reflections are visible

