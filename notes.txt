
plan (priority - only a few items here plz):
  . make the world into an octree - so objects inside this octree
    . VoxelOctree, ObjectOctree or WorldOctree
  /. optimise ray traversal -ve t (more info below) **IMP
  /. how do i do dielectric voxels?
    /. better name than "volumetric" ?
    /. total internal reflection is a pain for voxels.
      \. maybe add a trigger for this?
      \. it seems, voxels quite often just give very long streaks of reflections (>1000)
      . if tir persists for long time, maybe turn it off somehow (for each ray)
        . pass the bounce_depth in scatter?
  . multi-thread syncronised progress indicator
    . what can i do to not slow this down?
      . maybe use channels?
      . atomic add method
  . better img.rs
  . is the function for world(relative to main octree) coords of voxels useful? - then make it
  . triangle mesh importing and tracing (later can be voxelised)
  . add readme with pics and submit it in rt1wk implimentations

todo/ideas:
  . use f64::infinity or whatever consts
  . multiple samples if material is lambertian ????
  . multi-colored materials (all types?)
    . an extra enum for this? - it can have all the different coloring patterns in it
    . this will look cool on random objects (like the velvet coats or whatever)
    . color as a function of direction of normal (like that of sky)
    . color as func of angle with normal?
  . better fresnel or whatever
    . instead of randomising reflection and refraction, a part of them should bounce and a part should refract
  . make this do the termiRen stuff too
    . dosent seem to difficult - just modify the world struct a bit
  . look into signed distance fields
  . more materials
    . textures
      . custom textured skybox - just another sphere??
    . mixture of metal and lembertian and etc
      . some probability that it behaves in a way
      . can i just have 1 material then?
        . with different settings
    . hollowgram like material
    . is sub-surface scatterng doable for me?
  . fog
    . get 2 limits for t (where there is fog)
    . some probability that it passes/interacts depending on t
    . if interacts, pick some t in the range
    . let it bounce in random direction
    . use voxels? - more ideas in "octree" below
  . 3d fractals using distance estimate funcs for mandlebulb etc
  . a portal
    . maybe any shape + coupled objects
      . different ways the ray comes out
        . fuzz
        . direction
        . color
    . how do i make the objects teleport through these?
  . aabbs for every object + put them in octrees
  . triangle meshes
    . how do i store the vertices? just a vec wouldnt be very efficient
    . maybe mesh bounding box, + some structure with bounding boxes of groups of triangles
    . keep position in struct, we can move objects without having to modify all vertices using it
      . ray pos -= position
      . will also have to keep a matrix to rotate the ray dir correctly
      . this isnt very efficient for static scenes tho cuz we dont need to move objects often
    . maybe aabb thing for triangels and oct-tree for rest?
    . oct-tree
      . i can use marching cubes to create terrain and render it on fly (dont need to store it)
        . if storage is a big prob, then create it while tracing rays, tho this will be slow af
        . mayebe i can cache a few cubes so that we only create the cube once (per thread) and reuse it for all rays in that pixel (group of pixels)
      . how do i store triangles in it tho?
        \. triangles can be huge and will have to exist in multiple cubes
          \. sorting is kinda easy once we have the cubes - just use the bounding box to add it to every cube it intersects with
        \. or triangles can be stored in oct-tree using some index in array of triangles
          \. finding what cubes to put the triangle in is a pain tho. but atleast it doable this way
          \. so, go through each triangle and see what cubes it should be in, then re-do that part of oct-tree for max no. of things in a voxel thing
             or whatever in recursive fashion
            \. but some exceptions should be there while doing this, cuz many triangles can share same vertex
        \. or clip triangles till it fits in a leaf + limit to how small it can go
        . OR store a triangle in the smallest cube it fits in, dosent matter if its a leaf or branch
          . this way, no duplicates
    . how voxelise meshes?
      . triangle meshes are closed usually, so maybe first voxelize every voxel that intersects triangles and then flood-fill the interior
        . the interior can have big voxels
      . maybe voxels can be filled like rasterisation. move a point along the area of triangle and put a voxel there
        . for more accurate things, insert the point a few more levels deep and check if it lies closeish to the centre or lies along boundaries
        . if it lies along the boundaries, then we can either ignore the voxel or check a few more things
          . the normsls of triangles usually point outside, so maybe this can be used to decide if a voxel should go in or not
      . flood-fill the outside and then invert it
      . find bb and sample 8 points within a voxel to decide if it should be filled
        either every voxel.in this can be checked (recursive) (cuz simpler)
        or only check (recursive) that actually intersect
  . octree
    . if multithreading gives trouble with arc and stuff, try the share/sync trait
    . this seems slowish, profiling needed
    . see ram stats + how crazy can i go with it.
      . deepsize on github (idk if crate)
      . as of 2/9/21, it uses about 85MB total (RES memory from top command)
        . out of which around 55MB should be image buffers
        . 100k voxel inputs with normals
      . can i load minecraft maps in it?
    . voxel normals
      . many voxels can have same normal (big triangle), can i do something to save space here?
        . like is no normal, check parents normal recursively
    /. dielectric voxels
      /. how
        /. ts and t have different signs, then return to main octree (with signal)
        /. octree then checks the signal and calls a special func to traverse volumetric or something
        /. this func checks if the next voxel is the same material as the one where raypos is
          and returns the t for which its either some other material (normal not reversed)
          if its another type of volumetric or air, it returns with the reversed normal
      . using the input normals for dielectric dont sound too accurate(cuz the ray can enter and exit from different planes), anything better i can do?
        . like use dt for direction change
        . or maybe dt and the cube infered normal + flipped normal
    /. can i optimise the traversal when ray pos is inside?
      /. ts -ve, just go to it and ignore the children at current t
      /. if ts[0] is -ve, it means that the currently hit voxel is completely behind the ray
      /. add this statement just after computing ts
        /. jump to that ts which is greatest and -ve
        /. OR if ts < 0 then just dont go inside the voxel
        /. since all next voxels need to be calculated anyway, just add it in first line of try_hit_subvoxel
        /. if ts_p1.t < 0.0 {return None} // since ts > t and ts < 0 -> this voxel is completely behind the ray, so no need to enter
    . compression
      . voxels with no normals and default materials can be considered mergable with voxels that have materials and normals (if not visible)
      . merge similar sibling voxels if all 8 are similar
    . change ray cast depth as t increases maybe?
  . more shapes
    . rays/lines (will be cool to view rays)
      . how? these are a bit too thin
    . lens
      . this is just the intersection of 2 spheres, so its only where t for both exists for a ray
        but some more constraints are needed, like maybe it should hit outer of sp1 and then inner of sp2
      . m_t_s1 < p_t_s2 where s1 is the sphere further away from ray.pos
        how? -> whenever ray intersects both, it will (mostly) have 4 sols
        so just pick the middle 2  (m_t is ((-b-root(D))/4a) and p_t is -b+rootD...)
    . parabolic/spherical surfaces
  . implement the 3d matrix rotations stuff
    . maybe the current stuff is plenty for this
  . what would happen if i just use 4d vectors and 4d objects (consider a teseract)
    rotate the needed vectors with rotation matrices and and try to render it with similar tech as 3d
    . 3d images? (assigning colors to 3d pixels) can i do anything with this?
      . average the colors down to 2d
    . 2d images?

remember:
  . try reflections from inside a big sphere
    . its too dark, no reflections are visible

