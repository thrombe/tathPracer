
plan (priority - only a few items here plz):
  . make the world into an octree - so objects inside this octree
  /. if voxels have no normal, infer it from the t and t_plane (so it acts like a square)
  . is the function for world(relative to main octree) coords of voxels useful? - then make it
  . triangle mesh importing and tracing (later can be voxelised)

todo/ideas:
  . use f64::infinity or whatever consts
  . multiple samples if material is lambertian ????
  . multi-colored materials (all types?)
    . this will look cool on random objects (like the velvet coats or whatever)
    . color as a function of direction of normal (like that of sky)
    . color as func of angle with normal?
  . better fresnel or whatever
    . instead of randomising reflection and refraction, a part of them should bounce and a part should refract
  . make this do the termiRen stuff too
    . dosent seem to difficult - just modify the world struct a bit
  . look into signed distance fields
  . more materials
    . textures
      . custom textured skybox - just another sphere??
    . mixture of metal and lembertian and etc
      . some probability that it behaves in a way
      . can i just have 1 material then?
        . with different settings
    . is sub-surface scatterng doable for me?
  . fog
    . get 2 limits for t (where there is fog)
    . some probability that it passes/interacts depending on t
    . if interacts, pick some t in the range
    . let it bounce in random direction
    . use voxels? - more ideas in "octree" below
  . 3d fractals using distance estimate funcs for mandlebulb etc
  . a portal
    . maybe any shape + coupled objects
      . different ways the ray comes out
        . fuzz
        . direction
        . color
    . how do i make the objects teleport through these?
  . aabbs for every object + put them in octrees
  . triangle meshes
    . how do i store the vertices? just a vec wouldnt be very efficient
    . maybe mesh bounding box, + some structure with bounding boxes of groups of triangles
    . keep position in struct, we can move objects without having to modify all vertices using it
      . ray pos -= position
      . will also have to keep a matrix to rotate the ray dir correctly
      . this isnt very efficient for static scenes tho cuz we dont need to move objects often
    . maybe aabb thing for triangels and oct-tree for rest?
    . oct-tree
      /. this way, i can have a lot of objects without too much probs
      . i can use marching cubes to create terrain and render it on fly (dont need to store it)
        . if storage is a big prob, then create it while tracing rays, tho this will be slow af
        . mayebe i can cache a few cubes so that we only create the cube once (per thread) and reuse it for all rays in that pixel (group of pixels)
      . how do i store triangles in it tho?
        \. triangles can be huge and will have to exist in multiple cubes
          \. sorting is kinda easy once we have the cubes - just use the bounding box to add it to every cube it intersects with
        \. or triangles can be stored in oct-tree using some index in array of triangles
          \. finding what cubes to put the triangle in is a pain tho. but atleast it doable this way
          \. so, go through each triangle and see what cubes it should be in, then re-do that part of oct-tree for max no. of things in a voxel thing
             or whatever in recursive fashion
            \. but some exceptions should be there while doing this, cuz many triangles can share same vertex
        \. or clip triangles till it fits in a leaf + limit to how small it can go
        . OR store a triangle in the smallest cube it fits in, dosent matter if its a leaf or branch
          . this way, no duplicates
      . maybe convert triangle meshes into voxel things first and then do the tracing
        . how voxelise?
          . triangle meshes are closed usually, so maybe first voxelize every voxel that intersects triangles and then flood-fill the interior
            . the interior can have big voxels
          . maybe voxels can be filled like rasterisation. move a point along the area of triangle and put a voxel there
            . for more accurate things, insert the point a few more levels deep and check if it lies closeish to the centre or lies along boundaries
            . if it lies along the boundaries, then we can either ignore the voxel or check a few more things
              . the normsls of triangles usually point outside, so maybe this can be used to decide if a voxel should go in or not
          . flood-fill the outside and then invert it
          . triangle voxelise
            . find bb and sample 8 points within a voxel to decide if it should be filled
            . either every voxel.in this can be checked (recursive) (cuz simpler)
              or only check (recursive) that actually intersect
  . octree
    . a kind of problemish is there. inserting a smol voxel inside a earlier big voxel kinda makes the bigger one not visible in images
      . this may be desirable tho, cuz this way, we can create models with different colors for bigger voxels
        like, recursively voxelising something in greater and greater detail with maybe different colors for each level
    . if multithreading gives trouble with arc and stuff, try the share/sync trait
    . this seems slowish, profiling needed
    . see ram stats + how crazy can i go with it.
      . deepsize on github (idk if crate)
      . as of 2/9/21, it uses about 85MB total (RES memory from top command)
        . out of which around 55MB should be image buffers
        . 100k voxel inputs with normals
      . can i load minecraft maps in it?
    . voxel normals
      . many voxels can have same normal (big triangle), can i do something to save space here?
        . like is no normal, check parents normal recursively
      /. can i make voxels into cubes? (the normals stuff i mean)
        /. should i? - just adding a custom cube object in octree seems good enough
        /. this may mean that i dont need to store normals for these, and this would be nice for space reasons
        /. this will be useful for minecraft like things tho, so it reduces sizes by a heck lot
    . change ray cast depth as t increases maybe?
    . i dont think Dielectric material would work good here (not yet atleast)
      . maybe another "volumetric_mask" per voxel?
        . material_mask can go u16
        . these dont require normals
          . maybe they do, glass can have a normal, and while going out, you flip this normal
            . dosent sound too accurate, anything better i can do?
            . like use dt for direction change
            . or maybe dt and the cube infered normal + flipped normal
          . they can either be randomised (for fog stuff), or inferred from the t_plane + ray.dir or something
      . so it can have a different reaction when leaving voxel
        . leaving voxel - check ray pos and use t1
        . when leaving the try_hit_subvoxel, it can call something else maybe
    . compression
      . voxels with no normals and default materials can be considered mergable with voxels that have materials and normals (if not visible)
  . more shapes
    . rays/lines (will be cool to view rays)
      . how? these are a bit too thin
    . lens
      . this is just the intersection of 2 spheres, so its only where t for both exists for a ray
        but some more constraints are needed, like maybe it should hit outer of sp1 and then inner of sp2
      . m_t_s1 < p_t_s2 where s1 is the sphere further away from ray.pos
        how? -> whenever ray intersects both, it will (mostly) have 4 sols
        so just pick the middle 2  (m_t is ((-b-root(D))/4a) and p_t is -b+rootD...)
    . parabolic/spherical surfaces
  . implement the 3d matrix rotations stuff
    . maybe the current stuff is plenty for this
  . what would happen if i just use 4d vectors and 4d objects (consider a teseract)
    rotate the needed vectors with rotation matrices and and try to render it with similar tech as 3d
    . 3d images? (assigning colors to 3d pixels) can i do anything with this?
      . average the colors down to 2d
    . 2d images?

remember:
  . try reflections from inside a big sphere
    . its too dark, no reflections are visible

